Additional context is provided below.

Preferences for python code:
- adhere to common style conventions, e.g. PEP8
- you MUST keep lines under 80 characters long

Markdown2confluence pushes a folder containing markdown files and pushes them to confluence, with a page structure like the file and folder structure of the markdown files, and ignoring any non-markdown files.

Required behavior:
- All pages managed by markdown2confluence contains a suffix, e.g. '(autogenerated)'. New pages are created with this suffix, and on subsequent runs any pages with the suffix (or label, TBD) are overwritten or deleted. Depending on how confluence labels work it might be best to use labels instead. If using labels, refuse to delete any pages that does not have the page title suffix.
- Any markdown that contains full or relative links to local media files should be published as pages with attached media. Relative links in markdown to local media are resolved from the location of the markdown file. Full-path links in markdown are resolved from the $MARKDOWN_FOLDER


file structure:
markdown2confluence/
├── CODEOWNERS
├── Dockerfile
├── docs
│   └── usage.md
├── LICENCE
├── markdown2confluence
│   ├── converter.py
│   ├── __init_.py
│   ├── main.py
│   ├── confluence.py
│   ├── config.py
│   ├── content_tree.py
│   ├── parser.py
│   ├── util.py
│   ├── version.py
│   └── publisher.py
├── README.md
├── requirements.txt
├── setup.py
└── tests
    ├── e2e
    │   ├── __init__.py
    │   └── test_e2e.py
    ├── integration
    │   ├── __init__.py
    │   └── test_integration.py
    └── unit
        ├── __init__.py
        ├── test_parser.py
        ├── test_confluence.py
        └── test_publisher.py

arguments:
--confluence-url
--confluence-username
--confluence-password
--confluence-space-id
--confluence-parent-page-id
--markdown-folder
--confluence-page-title-suffix
--confluence-page-label
--confluence-ignorefile

and corresponding environment variables:
CONFLUENCE_URL
CONFLUENCE_USERNAME
CONFLUENCE_PASSWORD
CONFLUENCE_SPACE_ID
CONFLUENCE_PARENT_PAGE_ID
MARKDOWN_FOLDER
CONFLUENCE_PAGE_TITLE_SUFFIX
CONFLUENCE_PAGE_LABEL
CONFLUENCE_IGNOREFILE


### Architecture Summary

#### Components and Their Key Interfaces

1. **Publisher**

Abstract Publisher class for publishing a content tree, respecting the ContentTree structure and managing page relationships.

```python
class Publisher:
    @abstractmethod
    def publish_node(self, node: ContentNode, parent_id: str | None) -> str:
        pass

    def pre_publish_hook(self):
        """
        Optional step for actions to perform before publishing, such as
        fetching/deleting previously published resources.
        Can be overridden by subclasses.
        """
        pass

    def post_publish_hook(self):
        """
        Optional step for actions to perform after publishing, such as
        cleaning up resources or performing additional logging.
        Can be overridden by subclasses.
        """
        pass

    def publish_content(self, content_tree: ContentTree):
        """
        Traverse a content tree and call publish_node on each element.
        """
        pass
```

2. **ConfluencePublisher**

Specialized publisher for confluence, implements the publish_node function responsible for creating/updating pages with labels etc in confluence

```python
class ConfluencePublisher(Publisher):
    def __init__(self, confluence: Confluence = None):
        pass

    def pre_publish_hook(self):
        """
        Specialized for this subclass.
        Fetch all pages matching space, label and suffix
        """

    def post_publish_hook(self):
        """
        Specialized for this subclass.
        Delete pages not in the ContentTree
        """

    def publish_node(self, node: ContentNode, parent_id: str | None) -> str:
        """
        Create or update pages, including attachments, ensuring labels on newly created pages.
        """
        pass
```

3. **Parser**

Responsible for parsing the source files from e.g. the file system.

```python
class Parser(ABC):
    @abstractmethod
    def parse_directory(self, directory: str) -> ContentTree:
        pass


class MarkdownParser(Parser):
    def parse_directory(self, directory: str) -> ContentTree:
        pass
```

4. **ContentTree**

Defines the shared data structure for content between Parser and Publisher

```python
@dataclass
class ContentNode:
    name: str
    content: [str] | None = None
    metadata: [dict] | None = None
    parent: ['ContentNode'] | None = None
    children: dict[str, 'ContentNode'] = field(default_factory=dict)

@dataclass
class ContentTree:
    root: ContentNode = field(default_factory=lambda: ContentNode('root'))
``
